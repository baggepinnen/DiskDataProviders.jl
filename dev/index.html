<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DiskDataProviders · DiskDataProviders</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiskDataProviders</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>DiskDataProviders</a><ul class="internal"><li><a class="toctext" href="#Supervised-vs-unsupervised-1">Supervised vs unsupervised</a></li><li><a class="toctext" href="#Usage-example-1">Usage example</a></li><li class="toplevel"><a class="toctext" href="#Preprocess-data-1">Preprocess data</a></li><li class="toplevel"><a class="toctext" href="#Exported-functions-and-types-1">Exported functions and types</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DiskDataProviders</a></li></ul><a class="edit-page" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DiskDataProviders</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/baggepinnen/DiskDataProviders.jl"><img src="https://travis-ci.org/baggepinnen/DiskDataProviders.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/baggepinnen/DiskDataProviders.jl"><img src="https://codecov.io/gh/baggepinnen/DiskDataProviders.jl/branch/master/graph/badge.svg" alt="codecov"/></a></p><h1><a class="nav-anchor" id="DiskDataProviders-1" href="#DiskDataProviders-1">DiskDataProviders</a></h1><div></div><p>This package implements datastructures that are iterable and backed by a buffer that is fed by data from disk. If Reading and preproccesing data is faster than one training step, it&#39;s recommended to use a <a href="#DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{ChannelDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>ChannelDiskDataProvider</code></a>, if the training step is fast but reading data takes long time, <a href="#DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{QueueDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>QueueDiskDataProvider</code></a> is recommended. Both types do the reading on a separate thread, so make sure Julia is started with at least two threads.</p><h2><a class="nav-anchor" id="Supervised-vs-unsupervised-1" href="#Supervised-vs-unsupervised-1">Supervised vs unsupervised</a></h2><p>If the task is supervised, you may supply labels using the keyword <code>labels</code>, see example below. If the dataset has labels, it iterates tuples <code>(x,y)</code>. If no labels are supplied, it iterates only inputs <code>x</code>. To create an unsupervised dataset with no labels, use <code>Nothing</code> as the label type, e.g. <code>DiskDataProvider{xType, Nothing}</code>.</p><h2><a class="nav-anchor" id="Usage-example-1" href="#Usage-example-1">Usage example</a></h2><pre><code class="language-julia">using DiskDataProviders, Test, Serialization, MLDataUtils

# === Create some random example data ===
dirpath = mktempdir()*&quot;/&quot;
N = 100
T = 500
batch_size = 2
queue_length = 5 # Length of the internal buffer.
labs = rand(1:5, N)
for i = 1:N
    a = randn(T)
    serialize(dirpath*&quot;$(i).bin&quot;, (a, labs[i]))
end

files = dirpath .* string.(1:N) .* &quot;.bin&quot;

# === Create a DiskDataProvider ===
dataset = ChannelDiskDataProvider{Vector{Float64}, Int}((T,), batch_size, queue_length; labels=labs, files=files)</code></pre><pre><code class="language-none">ChannelDiskDataProvider{Array{Float64,1},Int64,Array{Float32,2}}, length: 100
</code></pre><p>The dataset is iterable and can be used in loops etc. One can also create a <a href="@ref"><code>BatchView</code></a>, which is an iterator over batches. The batch size is defined when the DiskDataProvider is created.</p><pre><code class="language-julia-repl">julia&gt; # === Example usage of the provider ===
       datasett, datasetv = stratifiedobs(dataset, 0.75)
(ChannelDiskDataProvider{Array{Float64,1},Int64,Array{Float32,2}}, length: 75
, ChannelDiskDataProvider{Array{Float64,1},Int64,Array{Float32,2}}, length: 25
)

julia&gt; sort(dataset.ulabels) == 1:5
true

julia&gt; x,y = first(dataset) # Get one datapoint
([2.3445050218762904, 0.4899644142887545, 0.041812411779015755, -0.9669280145391984, -0.2304810535167725, -0.6179636426653371, -0.14717189373759448, 1.5673114527790837, -0.03337569225185964, -0.08523993031093714  …  -1.4889858089607153, 1.4562037231782383, -0.08499299819681604, 0.1000925210967213, -1.082244981602152, -2.5090658647994832, -1.6125117506492472, -0.11216903619291987, -0.15636163199819472, -0.29356775071839475], 3)

julia&gt; t = start_reading(dataset) # this function initiates the reading into the buffer
[ Info: Populating queue continuosly. Call `stop!(d)` to stop reading`. Call `wait(d)` to be notified when the queue is fully populated.
Task (runnable) @0x00007f08b3795870

julia&gt; wait(dataset) # Wait for the reading to start before proceeding

julia&gt; bw = batchview(dataset);

julia&gt; xb,yb = first(bw) # Get the first batch from the buffer
(Float32[0.9910538 -1.0803226; -0.38291112 -0.5915521; … ; 0.30955932 -0.37994853; 0.5860136 1.0566654], [1, 4])

julia&gt; for (x,y) in bw # Iterate the batches in the batchview
           # do something with the data
       end

julia&gt; stop!(dataset) # Stop reading into the buffer
false</code></pre><p>If your data has more dimensions than 1, e.g., inputs are matrices or 3d-tensors, you create a DiskDataProvider like this</p><pre><code class="language-julia">dataset = ChannelDiskDataProvider((nrows,ncols,nchannels), batchsize, queuelength; labels=labs, files=files)</code></pre><p>notice that you have to provide <code>nchannels</code>, which is <code>1</code> if the input is a matrix.</p><h1><a class="nav-anchor" id="Preprocess-data-1" href="#Preprocess-data-1">Preprocess data</a></h1><p>All functionality in this package operates on serialized, preprocessed data files. Serialized files are fast to read, and storing already preprocessed data cuts down on overhead. This package does currently not support arbitrary file formats. The files are read using Julias built in deserializer.</p><h1><a class="nav-anchor" id="Exported-functions-and-types-1" href="#Exported-functions-and-types-1">Exported functions and types</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#DiskDataProviders.BufferedIterator"><code>DiskDataProviders.BufferedIterator</code></a></li><li><a href="#DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{XT}, Tuple{Any,Any,Int64}} where YT where XT"><code>DiskDataProviders.ChannelDiskDataProvider</code></a></li><li><a href="#DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{ChannelDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>DiskDataProviders.ChannelDiskDataProvider</code></a></li><li><a href="#DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{XT}, Tuple{Any,Any,Int64}} where YT where XT"><code>DiskDataProviders.QueueDiskDataProvider</code></a></li><li><a href="#DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{QueueDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>DiskDataProviders.QueueDiskDataProvider</code></a></li><li><a href="#DiskDataProviders.UnbufferedIterator"><code>DiskDataProviders.UnbufferedIterator</code></a></li><li><a href="#MLDataPattern.batchview-Tuple{Any}"><code>MLDataPattern.batchview</code></a></li><li><a href="#DiskDataProviders.labels-Tuple{Any}"><code>DiskDataProviders.labels</code></a></li><li><a href="#DiskDataProviders.sample_input-Tuple{Any}"><code>DiskDataProviders.sample_input</code></a></li><li><a href="#DiskDataProviders.sample_input-Tuple{Any,Any}"><code>DiskDataProviders.sample_input</code></a></li><li><a href="#DiskDataProviders.sample_label-Tuple{Any}"><code>DiskDataProviders.sample_label</code></a></li><li><a href="#DiskDataProviders.start_reading-Tuple{DiskDataProviders.AbstractDiskDataProvider}"><code>DiskDataProviders.start_reading</code></a></li><li><a href="#MLDataPattern.stratifiedobs-Tuple{DiskDataProviders.AbstractDiskDataProvider,AbstractFloat,Vararg{Any,N} where N}"><code>MLDataPattern.stratifiedobs</code></a></li><li><a href="#StatsBase.nobs-Tuple{Any}"><code>StatsBase.nobs</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{ChannelDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT" href="#DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{ChannelDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>DiskDataProviders.ChannelDiskDataProvider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ChannelDiskDataProvider(d::ChannelDiskDataProvider, inds::AbstractArray)</code></pre><p>This constructor can be used to create a dataprovider that is a subset of another.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L135-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{XT}, Tuple{Any,Any,Int64}} where YT where XT" href="#DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{XT}, Tuple{Any,Any,Int64}} where YT where XT"><code>DiskDataProviders.ChannelDiskDataProvider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ChannelDiskDataProvider{XT, YT}(xsize, batchsize, queuelength::Int; kwargs...) where {XT, YT}</code></pre><p>Constructor for ChannelDiskDataProvider. <code>{XT, YT}</code> are the types of the input and output respectively.</p><p>#Arguments:</p><ul><li><code>xsize</code>: Tuple with sixe of each data point</li><li><code>batchsize</code>: how many datapoints to put in a batch</li><li><code>queuelength</code>: length of buffer</li><li><code>kwargs</code>: to set the other fields of the structure.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L107-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{QueueDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT" href="#DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{QueueDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>DiskDataProviders.QueueDiskDataProvider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">QueueDiskDataProvider(d::QueueDiskDataProvider, inds::AbstractArray)</code></pre><p>This constructor can be used to create a dataprovider that is a subset of another.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{XT}, Tuple{Any,Any,Int64}} where YT where XT" href="#DiskDataProviders.QueueDiskDataProvider-Union{Tuple{YT}, Tuple{XT}, Tuple{Any,Any,Int64}} where YT where XT"><code>DiskDataProviders.QueueDiskDataProvider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">QueueDiskDataProvider{XT, YT}(xsize, batchsize, queuelength::Int; kwargs...) where {XT, YT}</code></pre><p>Constructor for QueueDiskDataProvider.</p><p><code>{XT, YT}</code> are the types of the input and output respectively.</p><p>#Arguments:</p><ul><li><code>xsize</code>: Tuple with sixe of each data point</li><li><code>batchsize</code>: how many datapoints to put in a batch</li><li><code>queuelength</code>: length of buffer</li><li><code>kwargs</code>: to set the other fields of the structure.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L35-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.labels-Tuple{Any}" href="#DiskDataProviders.labels-Tuple{Any}"><code>DiskDataProviders.labels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">labels(d)</code></pre><p>Return the labels in the dataset</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L176-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.sample_input-Tuple{Any,Any}" href="#DiskDataProviders.sample_input-Tuple{Any,Any}"><code>DiskDataProviders.sample_input</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sample_input(d::AbstractDiskDataProvider, y)</code></pre><p>Sample one input with label <code>y</code> from the dataset</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L267-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.sample_input-Tuple{Any}" href="#DiskDataProviders.sample_input-Tuple{Any}"><code>DiskDataProviders.sample_input</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sample_input(d::AbstractDiskDataProvider)</code></pre><p>Sample one datapoint from the dataset</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L279-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.sample_label-Tuple{Any}" href="#DiskDataProviders.sample_label-Tuple{Any}"><code>DiskDataProviders.sample_label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sample_label(d)</code></pre><p>Sample a random label from the dataset</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L255-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.start_reading-Tuple{DiskDataProviders.AbstractDiskDataProvider}" href="#DiskDataProviders.start_reading-Tuple{DiskDataProviders.AbstractDiskDataProvider}"><code>DiskDataProviders.start_reading</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">start_reading(d::AbstractDiskDataProvider)</code></pre><p>Initialize reading into the buffer. This function has to be called before the dataset is used. Reading will continue until you call <code>stop!</code> on the dataset. If the dataset is a <a href="#DiskDataProviders.ChannelDiskDataProvider-Union{Tuple{YT}, Tuple{ChannelDiskDataProvider{#s44,YT,BT} where BT where #s44,AbstractArray}} where YT"><code>ChannelDiskDataProvider</code></a>, this is a non-issue.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/DiskDataProviders.jl#L243-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.BufferedIterator" href="#DiskDataProviders.BufferedIterator"><code>DiskDataProviders.BufferedIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct BufferedIterator{T &lt;: AbstractDiskDataProvider}</code></pre><p>Creates an iterator which uses the underlying buffer in the dataset.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/iteration.jl#L79-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiskDataProviders.UnbufferedIterator" href="#DiskDataProviders.UnbufferedIterator"><code>DiskDataProviders.UnbufferedIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct UnbufferedIterator{T &lt;: AbstractDiskDataProvider}</code></pre><p>Creates an iterator which does not use the underlying buffer in the dataset.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/iteration.jl#L88-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataPattern.batchview-Tuple{Any}" href="#MLDataPattern.batchview-Tuple{Any}"><code>MLDataPattern.batchview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">batchview(d::AbstractDiskDataProvider; size=d.batchsize, kwargs...)</code></pre><p>Create a batch iterator that iterates batches with the batch size defined at the creation of the DiskDataProvider.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/iteration.jl#L168-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLDataPattern.stratifiedobs-Tuple{DiskDataProviders.AbstractDiskDataProvider,AbstractFloat,Vararg{Any,N} where N}" href="#MLDataPattern.stratifiedobs-Tuple{DiskDataProviders.AbstractDiskDataProvider,AbstractFloat,Vararg{Any,N} where N}"><code>MLDataPattern.stratifiedobs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stratifiedobs(d::AbstractDiskDataProvider, p::AbstractFloat, args...; kwargs...)</code></pre><p>Partition the data into multiple disjoint subsets proportional to the value(s) of p. The observations are assignmed to a data subset using stratified sampling without replacement. These subsets are then returned as a Tuple of subsets, where the first element contains the fraction of observations of data that is specified by the first float in p.</p><p>For example, if p is a Float64 itself, then the return-value will be a tuple with two elements (i.e. subsets), in which the first element contains the fraction of observations specified by p and the second element contains the rest. In the following code the first subset train will contain around 70% of the observations and the second subset test the rest. The key difference to splitobs is that the class distribution in y will actively be preserved in train and test.</p><p><code>train, test = stratifiedobs(diskdataprovider, 0.7)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/iteration.jl#L133-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.nobs-Tuple{Any}" href="#StatsBase.nobs-Tuple{Any}"><code>StatsBase.nobs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">LearnBase.nobs(d)</code></pre><p>Get the number of observations in the dataset</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/DiskDataProviders.jl/blob/13ca65ed702f27dd2a6141989422b601d72224b9/src/iteration.jl#L181-L185">source</a></section><footer><hr/></footer></article></body></html>
